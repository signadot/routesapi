syntax = "proto3";

option go_package = "github.com/signadot/routesapi/routesapi-go;routesapi";

package routes;

service Routes {
  // GetWorkloadRoutes returns a set of workload routing rules, each of which
  // indicates how to direct requests destined to a given baseline workload with
  // a given routing key.
  rpc GetWorkloadRoutes(WorkloadRoutesRequest) returns (GetRoutesResponse) {}

  // WatchWorkloadRoutes provides a stream of diff operations which operate on a
  // set of workload routing rules to maintain the routing rules in near real
  // time with in-cluster Sandboxes and RouteGroups.
  rpc WatchWorkloadRoutes(WorkloadRoutesRequest) returns (stream WorkloadRuleOp) {}
}


// Common
// ----------------------------------------------------------------------------

// A WorkloadRule "r" means: if a request 
//   1. has r.RoutingKey; and 
//   2. is originally destined to r.SandboxedWorkload.Baseline; and
//   3. is sent on a port indicated in one of r.PortRules `pr`
// then send it to the host and port indicated in any destination host and port
// indicated in pr.destinations. Moreover, these destinations are all addresses
// of r.SandboxedWorkload, any one of them can be used.
message WorkloadRule {
  string routing_key = 1;
  SandboxedWorkload sandboxed_workload = 2;
  repeated WorkloadPortRule port_rules = 3;
}

// A SandboxedWorkload represents a Fork or a Local workload running in a
// sandbox.
message SandboxedWorkload {
  // SandboxID indicates the routing key of a Sandbox.
  string sandbox_id = 1;

  // Baseline indicates the corresponding baseline workload.
  BaselineWorkload baseline = 2;
}

// A BaselineWorkload identifies a given baseline workload. In the context of a
// WorkloadRoutesRequest, all the fields are optional. In the context of a
// response from the server, all the fields are filled in.
message BaselineWorkload {
  string kind = 1;
  string namespace = 2;
  string name = 3;
}

// WorkloadPortRule provides a mapping from a port on the workload to a set of
// destinations. The workload port is the same as the target port of a
// kubernetes service matching the workload. Each destination in the response
// corresponds to a sandbox service matching the sandboxed workload.  As a
// result, any of the destinations can be used.
message WorkloadPortRule {
  uint32 workload_port = 1;
  repeated Location destinations = 2;
}

// Location gives a TCP address as a host, port pair.
message Location {
  string host = 1;
  uint32 port = 2;
}


// GetWorkloadRoutes
// ----------------------------------------------------------------------------

// WorkloadRoutesRequest is a request for a set of WorkloadRules, which give
// information about how to route requests when they are intercepted at a given
// workload. Each field is optional and constrains the the set of WorkloadRules
// returned accordingly.
//
message WorkloadRoutesRequest {
  // baseline_workload specifies the kind, namespace, and name of the baseline
  // workload to which requests are directed. Each field is optional.
  BaselineWorkload baseline_workload = 1;

  // routing_key specifies the routing key associated with the request.
  string routing_key = 2;

  // sandbox_id specifies the routing key of the sandbox associated 
  // with the sandboxed destination workload.
  string sandbox_id = 3;
}

// a GetRoutesResponse gives the set of WorkloadRules which match
// a given WorkloadRoutesRequest.
message GetRoutesResponse {
  repeated WorkloadRule rules = 1;
}


// WatchWorkloadRoutes
// ----------------------------------------------------------------------------

enum WatchOp {
  ADD = 0;
  REMOVE = 1;
  REPLACE = 2;
  // In any WatchWorkloadRoutes rpc call, the returned stream will send at most
  // 1 SYNCED WatchOp, indicating the client has all the information about
  // Sandboxes and RouteGroups available in the cluster. Prior to sending a
  // SYNCED WatchOp, all WatchOps are ADDs.
  SYNCED = 3;
}

// WorkloadRuleOp describes a diff operation against a set of workload routing
// rules: adding, removing, and replacing WorkloadRules are possible.
// Additionally, there is a SYNCED operation to indicate when the client has
// received all relevant WorkloadRules.
message WorkloadRuleOp {
  WatchOp op = 1;
  WorkloadRule rule = 2;
}
